<!-- omit in toc -->
# Assembly

<!-- omit in toc -->
## Table of Contents

1. [Structure](#structure)
2. [CPU Instructions](#cpu-instructions)
   1. [Arithmetic](#arithmetic)
   2. [Data Transfer](#data-transfer)
   3. [Control Flow](#control-flow)
      1. [Comparison Instructions](#comparison-instructions)
      2. [Jump Instructions](#jump-instructions)
      3. [Function Calls](#function-calls)
      4. [Others](#others)
   4. [Logical](#logical)
3. [Registers](#registers)
   1. [General Purpose](#general-purpose)
      1. [General Purpose (64-bit)](#general-purpose-64-bit)
      2. [Architecture Naming Conventions](#architecture-naming-conventions)
   2. [Segment](#segment)
   3. [EFLAGS](#eflags)
   4. [Instruction Pointer](#instruction-pointer)
4. [Stack](#stack)
5. [Memory](#memory)
6. [Tools](#tools)
   1. [Cutter](#cutter)

## Structure

- CPU Instructions: Instructions that are being executed in the CPU.
- Memory Registers:
- Stack: Place where information is held in order to access it in a fast way.

## CPU Instructions

### Arithmetic

TODO:

- Addition: `add dest,addend`
  - Adds addend to destination and stores the result in destination.
- Subtraction: `sub dest,subtrahend`
  - Subtract subtrahend from destination and stores the result in destination.
- Increment: `inc loc`
  - Increments the register value by 1.
- Decrement: `dec loc`
  - Decrements the value of register/memory by 1.

### Data Transfer
  
TODO:

- Move: `mov dest,src`
  - Immediate value -> Register: Yes. Into larger register.
  - Immediate value -> Memory: Yes. Up to 32-bit values.
  - Register -> Register: Yes. Same size.
  - Register -> Memory: Yes.
  - Memory -> Register: Yes. Register determines size of retrieved memory.
  - Memory -> Memory: No.
- Push: `push arg`
  - This instruction pushes a value to the stack, specifically, it decrements the stack pointer and stores the data specified as the argument into the location pointed to by the stack pointer.
- Pop: `pop arg`
  - This instruction pops a value from the stack, specifically, it loads the data stored in the location pointed to by the stack pointer into the argument specified and then increments the stack pointer.

### Control Flow

#### Comparison Instructions

- AND Comparison: `test accumulator,reference`
  - Performs an `AND` without modifying the operands.
  - Modifies the ZF(zero), SF(sign) and PF (parity) flags.
- Subtract comparison: `cmp minuend,subtrahend`
  - Performs a subtraction without modifying the operands.
  - Modifies the ZF(zero), SF(sign) and PF (parity) flags.

#### Jump Instructions

TODO:

- Unconditional Jump: `jmp loc`
  - Loads `EIP` with the specified address.
- Jump if Equal: `je loc`
  - Loads `EIP` with the specified address, if operands of previous `cmp`instructions are equal. `je` is identical to `jz`.
- Jump if Not Equal: `jne loc`
  - Loads `EIP` with the specified address, if the `minuend` of the previous `cmp` instruction is greater than the second (performs signed comparison).
- Jump if Zero: `jz loc`
  - Loads `EIP` with the specified address, if the zero bit is set from a previous arithmetic expression. `jz` is identical to `je`.
- Jump if Not Zero: `jnz loc`
  - Loads `EIP` with the specified address, if the zero bit is not set from a previous arithmetic expression. `jnz` is identical to `jne`.

#### Function Calls

- Call a process: `call proc`
  - Pushes the address of the instruction immediately following the `call` on to the stack. This is done to resume the current function after the invoked function is finished.
  - Jumps to the target address of the called function.
  - In some cases as `shellcode` the call is followed by a `pop` to obtain the current `EIP`.
  - Return value is stored in `EAX`.
- Return values: `ret [val]`
  - Pops the return address off the stack and the continues execution at that address.

#### Others

- Do nothing: `nop`
  - This instruction doesn't do anything, but wastes an instruction cycle in the processor.
- Wait: `wait`
  - Wait for the `FPU` to finish its last calculation.

### Logical

- Logical AND: `and dest,mask`
  - Performs a bit-wise `AND` of the two operands, and stores the result in destination.
- Logical OR: `or dest,addend`
  - Performs a bit-wise `OR` of the two operands, and stores the result in destination.
- Logical XOR: `xor dest,flip`
  - Performs a bit-wise `XOR` of the two operands, and stores the result in destination.
- Logical NOT: `not arg`
  - Performs a bit-wise inversion of argument.

## Registers

### General Purpose

1. AX (Accumulator Register): Used in arithmetic operations.
2. CX (Counter Register): Used in shift/rotate instructions and loops.
3. DX (Data Register): Used in arithmetic operations and I/O operations.
4. BX (Base Register): Used as a pointer to data (located in segment register DS, when in segmented mode).
5. SP (Stack Pointer Register): Pointer to the top of the stack.
6. BP (Stack Base Pointer Register): Used to point to he base of the stack.
7. SI (Source Index Register): Used as a pointer to a source in stream operations.
8. DI (Destination Index Register): Used as a pointer to a destination in stream operations.

Order is the same that is used in a push-to-stack operation.

#### General Purpose (64-bit)

- R8-R15 are the new 64-bit registers.
- R8D-R15D are the lowermost 32 bits of each registers.
- R8W-R15W are the lowermost 16 bits of each registers.
- R8B-R15B are the lowermost 8 bits of each registers.

Note: 64-bit x86 includes SSE2, so each 64-bit x86 CPU has at least 8 registers (named XMM0-XMM7) that are 128 bits wide, but only accessible trough SSE instructions. They cannot be used for quadruple-precision (128-bit) floating-point arithmetic, but they can each hold 2 double-precision or 4 single-precision floating-point values for a SIMD parallel instruction. They can also be operated on as 128-bit integers or vectors of shorter integers. If the processor supports AVX, as newer Intel and AMD desktop CPUs do, then each of these registers is actually the lower half of a 256-bit register (named YMM0â€“YMM7), the whole of which can be accessed with AVX instructions for further parallelization.

#### Architecture Naming Conventions

- 16-bit:
  - The register is identified by its two letter abbreviation from the list above.
- 32-bit:
  - This two letter abbreviation is prefixed with an 'E' (Extended). For example, `EAX`.
- 64-bit:
  - This two letter abbreviation is prefixed with and 'R' (Register). For example, `RAX`.
- 8-bit:
  - First four registers (AX, CX, DX and BX) in their 16-bit size, can be addressed as two 8-bit halves.
    - The least significant byte (LSB), or low half, is identified by replacing the 'X' with an 'L'. For example, `AL`.
    - The most significant byte (MSB), or high half, is identified by replacing the 'X' with an 'M'. For example, `AM`.

### Segment

- SS (Stack Segment): Pointer to the stack.
- CS (Code Segment): Pointer to the code.
- DS (Data Segment): Pointer to the data.
- ES (Extra Segment): Pointer to extra data.
- FS (F Segment): Point to more extra data.
- GS (G Segment): Point to still more extra data.

### EFLAGS

![EFLAGS](img/EFLAGS.png)

0. CF (Carry Flag): Set if the las arithmetic operation carried (addition) or borrowed (subtraction) a bit beyond the size of the register. This is then checked when the operation if followed with an add-with-carry or subtract-with-borrow to deal with values too large or just one register to contain.
2. PF (Parity Flag): Set if the number of set bits in the least significant byte is a multiple of 2.
4. AF (Adjust Flag): Carry of Binary Code Decimal (BCD) numbers arithmetic operations.
6. ZF (Zero Flag): Set if the result of an operation is 0.s
7. SF (Sign Flag): Set if the result of an operation is negative.
8. TF (Trap Flag): Set if step by step debugging.
9. IF (Interruption Flag): Set if interrupts are enabled.
10. DF (Direction Flag): Stream direction. If set, string operations will decrement their pointer rather than incrementing it, reading memory backwards.
11. OF (Overflow Flag): Set if signed arithmetic operations result in a value too large fot the register to contain.
12. IOPL (I/O Privilege Level Field (2bits -> 12,13)): I/0 Privilege Level of the current process.
13. 
14. NT (Nested Task Flag): Controls chaining of interrupts.
15. RF (Resume Flag): Response to debug exceptions.
16. VM (Virtual-8086 Mode): Set if in 8086 compatibility mode.
17. AC (Alignment Check): St if alignment checking of memory references is done.
18. VIF (Virtual Interrupt Flag): Virtual image to IF.
19. VIP (Virtual Interrupt Pending Flag): Set if an interrupt is pending.
20. ID (Identification Flag): Support for CPUID instruction if can be set.

### Instruction Pointer

The EIP register contains the address of the next instruction to be executed if no branching is done. EIP can only be read trough the stack after a `call` instruction.

## Stack

- The stack is a Last In First Out (LIFO) data structure. Data is pushed onto it and popped off ot it in the reverse order.
- Used to pass arguments to functions or procedures.
- Used to keep track of the control flow when te `call` instruction is used.
- Used to temporarily save registers.

## Memory

- The x86 architecture is little-endian. Multi-byte values are written least significant byte first (Ordering of the bytes not the bits).
  - For example, `0x1BA583D4` is seen as `0xD4 0x83 0xA5 0x1B` in memory.
- Two's complement is the standard way of representing negative integers in binary.
  - The sign is changed by inverting all of the bits and adding one.
- Addressing modes:
  - Register addressing: Operand address R is in the address field.
  
  ```asm
  mov ax,bx ; moves contents of register bx into ax
  ```

  - Immediate: Actual value is in the field.

  ```asm
  mov ax,1 ; moves value of 1 into register ax
  ```
  
  or

  ```asm
  mov ax,010CH ; moves value of 0x010C into register ax
  ```

  - Direct memory addressing: Operand address in the address field.

  ```asm
  .data
  my_var dw 0abcdh ; my_var = 0xabcd

  .code
  mov ax,[my_var] ; copy my_var content into ax (ax=0xabcd)
  ```
  
  - Direct offset addressing: Use arithmetics to modify address.

  ```asm
  byte table db 12,15,16,22 ; table of bytes
  mov al,[byte_table + 2]
  mov al,byte_table[2] ; same as previous instruction
  ```
  
  - Register indirect: Field points to a register that contains the operand address. The registers used for indirect addressing are BX, BP
  
  ```asm
  mov ax,[di]
  ```

## Tools

### Cutter

- Assembly decompiler.
- Identifies central function `main`.
- Tabs:
  - Graph: It represents the logical flow with assembly block codes.
  - Decompiler: Tries to reconstruct the assembly into a more readable pseudo-code.
